// Generated by CoffeeScript 1.3.3
(function() {
  var AttachedFile, Attachments, async, exports, mongoose, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  async = require('async');

  mongoose = require('mongoose');

  _ = require('underscore');

  AttachedFile = require('./attached_file');

  Attachments = new mongoose.Schema({
    name: {
      type: String,
      required: true
    },
    fileName: String,
    contentType: String,
    createdAt: {
      type: Date,
      "default": Date.now
    }
  }, {
    strict: true
  });

  Attachments.virtual('file').get(function() {
    return this._file;
  }).set(function(value) {
    return this._file = value;
  });

  Attachments.virtual('config').get(function() {
    return this.parent.schema.attachmentsConfig[this.name];
  });

  Attachments.virtual('attachedFile').get(function() {
    var _ref;
    return (_ref = this._attachedFile) != null ? _ref : this._attachedFile = new AttachedFile(this.parent.id, {
      modelName: this.config.modelName || this.parent.constructor.modelName,
      attributeName: this.name,
      fileName: this.fileName,
      styles: this.config.styles,
      file: {
        name: this.fileName,
        type: this.contentType,
        path: this.file
      }
    });
  });

  Attachments.path('contentType').validate(function(v) {
    var contentTypes;
    contentTypes = this.config.contentType;
    return !(contentTypes != null) || (__indexOf.call(contentTypes, v) >= 0);
  }, "acceptable content type");

  Attachments.method({
    url: function(style) {
      return this.attachedFile.url(style);
    },
    toObject: function(options) {
      var json, style, styles;
      json = mongoose.Model.prototype.toObject.call(this, options);
      if (options != null ? options.client : void 0) {
        styles = _.extend({
          original: ''
        }, this.config.styles);
        for (style in styles) {
          if (!__hasProp.call(styles, style)) continue;
          options = styles[style];
          json[style] = {
            url: this.url(style)
          };
        }
      }
      return json;
    }
  });

  Attachments.pre('save', function(next) {
    if (!(this.isNew && (this.file != null))) {
      return next();
    }
    return this.attachedFile.save(next);
  });

  Attachments.pre('remove', function(next) {
    var removeFn,
      _this = this;
    removeFn = function(cb) {
      _this.attachedFile.remove(cb);
      return _this.parent.removePre('save', removeFn);
    };
    this.parent.pre('save', removeFn);
    return next();
  });

  exports = module.exports = function(schema, options) {
    var name;
    name = options.name;
    schema.attachmentsConfig || (schema.attachmentsConfig = {});
    schema.attachmentsConfig[name] = options;
    if (!schema.path('attachments')) {
      schema.add({
        'attachments': [Attachments]
      });
      schema.method({
        addAttachment: function(name, value) {
          if (value.path != null) {
            return this.attachments.push({
              name: name,
              fileName: value.name,
              contentType: value.type,
              file: value.path
            });
          } else {
            value.name = name;
            return this.attachments.push(value);
          }
        }
      });
    }
    schema.virtual(name).get(function() {
      var att;
      if (options.collection) {
        return (function() {
          var _i, _len, _ref, _results;
          _ref = this.attachments;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            att = _ref[_i];
            if (att.name === name) {
              _results.push(att);
            }
          }
          return _results;
        }).call(this);
      }
      return _(this.attachments).find(function(a) {
        return a.name === name;
      });
    });
    schema.virtual(name).set(function(value) {
      var att, existing, v, _i, _j, _len, _len1, _ref;
      if (options.collection) {
        if (value.forEach == null) {
          throw new Error("Attachment value must be an array when collection=true. Add attachments with model.addAttachment(name, value).");
        }
        _ref = this.get(name);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          att = _ref[_i];
          att.remove();
        }
        for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
          v = value[_j];
          this.addAttachment(name, v);
        }
      } else {
        (existing = this.get(name)) && existing.remove();
        if (value != null) {
          this.addAttachment(name, value);
        }
      }
      this.attachments = this.attachments.slice(0);
      return this.markModified('attachments');
    });
    if (options.required) {
      schema.pre('validate', function(next) {
        var value;
        value = this.get(name);
        if (options.collection && value.length > 0 || (value != null)) {
          return next();
        }
        this.invalidate(name, 'required');
        return next();
      });
    }
    return schema.pre('remove', function(next) {
      var attachment, removes;
      removes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.attachments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attachment = _ref[_i];
          _results.push(function(cb) {
            return attachment.attachedFile.remove(cb);
          });
        }
        return _results;
      }).call(this);
      return async.parallel(removes, next);
    });
  };

  exports.Attachment = mongoose.model('Attachment', Attachments);

}).call(this);
